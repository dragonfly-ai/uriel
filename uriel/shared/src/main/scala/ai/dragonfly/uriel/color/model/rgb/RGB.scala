package ai.dragonfly.uriel.color.model.rgb

import narr.*
import ai.dragonfly.uriel.*
import ai.dragonfly.uriel.cie.*
import ai.dragonfly.uriel.color.model.*
import ai.dragonfly.mesh.*
import ai.dragonfly.mesh.shape.*
import slash.Random
import slash.matrix.*
import slash.vector.*

import scala.language.implicitConversions

trait RGB { self: WorkingSpace =>

  val `1/255`: Double = 1.0 / 255.0

  object RGB extends VectorSpace[RGB] {

    opaque type RGB = Vec[3]

    override lazy val usableGamut: Gamut = new Gamut( Cube(1.0, 32) )

    override val maxDistanceSquared: Double = 9.0

    def apply(values: NArray[Double]): RGB = dimensionCheck(values, 3).asInstanceOf[RGB]

    /**
     * Factory method to create a fully opaque RGB instance from separate, specified red, green, blue components and
     * a default alpha value of 1.0.
     * Double values that range outside of [0.0-1.0] may give unexpected results.  For values taken from user input, sensors,
     * or otherwise uncertain sources, consider using the factory method in the Color companion object.
     *
     * @see [[ai.dragonfly.color.ColorVectorSpace.RGB]] for a method of constructing RGB objects that validates inputs.
     * @param red   decimal value from [0.0-1.0] representing the red component in RGB space.
     * @param green decimal value from [0.0-1.0] representing the green component in RGB space.
     * @param blue  decimal value from [0.0-1.0] representing the blue component in RGB space.
     * @return an instance of the RGB case class.
     * @example {{{ val c = RGB(72,105,183) }}}
     */
    def apply(red: Double, green: Double, blue: Double): RGB = apply(NArray[Double](red, green, blue))

//    def apply(argb: ARGB32): RGB = apply(`1/255` * argb.red, `1/255` * argb.green, `1/255` * argb.blue)
//
//    def apply(rgba: RGBA32): RGB = apply(`1/255` * rgba.red, `1/255` * rgba.green, `1/255` * rgba.blue)

    //override def fromRGB(rgb: RGB): RGB = apply(rgb.red, rgb.green, rgb.blue)

    /**
     * Factory method to create a fully Opaque RGB color; one with an alpha value of 1.0.
     * Because this method validates each intensity, it sacrifices performance for safety.
     * Although well suited for parsing color data generated by sensors or user input, this method undercuts
     * performance in applications like reading image data.
     *
     * To skip validation and minimize overhead, @see [[ai.dragonfly.color.RGB.apply]]
     *
     * @param red   decimal value from [0.0-1.0] representing the red component in RGB space.
     * @param green decimal value from [0.0-1.0] representing the green component in RGB space.
     * @param blue  decimal value from [0.0-1.0] representing the blue component in RGB space.
     * @return an instance of the RGB class or None if fed invalid input.
     */

    def getIfValid(red: Double, green: Double, blue: Double): Option[RGB] = {
      if (valid0to1(red, green, blue)) Some(apply(red, green, blue))
      else None
    }

    /**
     * Use Color.random() to obtain a random color in the form of an RGB instance.
     * This method executes quickly and without memory costs, but the RGB color space biases toward cool colors.
     * In contrast, the Color.randomFromLabSpace() method takes seconds to initialize and has a memory footprint of several megabytes
     * However, it samples from a perceptually uniform color space and avoids the bias toward cool colors.
     * This method samples the Red, Green, and Blue color components uniformly, but always returns 1.0 for the alpha component.
     *
     * @return a randomly generated color sampled from the RGB Color ColorSpace.
     */
    override def random(r: scala.util.Random = Random.defaultRandom): RGB = Vec[3](r.nextDouble(), r.nextDouble(), r.nextDouble())

    def red(rgb:RGB):Double = rgb(0)
    def green(rgb:RGB):Double = rgb(1)
    def blue(rgb:RGB):Double = rgb(2)

    override def euclideanDistanceSquaredTo(c1: RGB, c2: RGB): Double = c1.euclideanDistanceSquaredTo(c2)

    override def fromVec(v: Vec[3]): RGB = v

    override def toVec(rgb: RGB): Vec[3] = rgb.asInstanceOf[Vec[3]].copy

    override def toRGB(rgb: RGB): RGB = rgb.copy
    override def fromRGB(rgb: RGB): RGB = rgb.copy

    override def toXYZ(rgb: RGB): XYZ = {
      (M * Mat[3, 1](
        transferFunction.decode(rgb.red),
        transferFunction.decode(rgb.green),
        transferFunction.decode(rgb.blue)
      )).values.asInstanceOf[XYZ]
    }
    override def fromXYZ(xyz:XYZ):RGB = xyz.toRGB

  }

//  case class RGB private(override val values: NArray[Double]) extends VectorColorModel[RGB] {
//    override type VEC = this.type with RGB
  type RGB = RGB.RGB

  given VectorColorModel[RGB] with {
    extension (rgb: RGB) {

      def red: Double = RGB.red(rgb)

      def green: Double = RGB.green(rgb)

      def blue: Double = RGB.blue(rgb)

      override def render: String = s"RGB($red, $green, $blue)"

      def copy: RGB = RGB(red, green, blue)

      override def toXYZ: XYZ = RGB.toXYZ(rgb)

      override def similarity(that: RGB): Double = RGB.similarity(rgb, that)

      override def toRGB: RGB = RGB(red, green, blue)
    }

  }
}

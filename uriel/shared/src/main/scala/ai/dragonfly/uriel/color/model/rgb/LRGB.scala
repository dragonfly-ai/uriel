/*
 * Copyright 2023 dragonfly.ai
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ai.dragonfly.uriel.color.model.rgb

import ai.dragonfly.mesh.shape.*
import ai.dragonfly.uriel.*
import ai.dragonfly.uriel.cie.*
import narr.*
import slash.*
import slash.vectorf.*
import slash.matrixf.*

import scala.language.implicitConversions

trait LRGB { self: WorkingSpace =>

  object LRGB extends VectorSpace[3, LRGB] {

    opaque type LRGB = VecF[3]

    override lazy val usableGamut: Gamut = new Gamut( Cube(1.0, 32).toMeshF )

    override val maxDistanceSquared: Double = 3f

    def apply(values: NArray[Float]): LRGB = dimensionCheck(values, 3).asInstanceOf[LRGB]

    /**
     * Factory method to create a fully opaque RGB instance from separate, specified red, green, blue components and
     * a default alpha value of 1.0.
     * Float values that range outside of [0.0-1.0] may give unexpected results.  For values taken from user input, sensors,
     * or otherwise uncertain sources, consider using the factory method in the Color companion object.
     *
     * @see [[ai.dragonfly.color.ColorVectorSpace.RGB]] for a method of constructing RGB objects that validates inputs.
     * @param red   decimal value from [0.0-1.0] representing the red component in RGB space.
     * @param green decimal value from [0.0-1.0] representing the green component in RGB space.
     * @param blue  decimal value from [0.0-1.0] representing the blue component in RGB space.
     * @return an instance of the RGB case class.
     * @example {{{ val c = RGB(72,105,183) }}}
     */
    def apply(red: Float, green: Float, blue: Float): LRGB = apply(NArray[Float](red, green, blue))

    /**
     * Factory method to create a fully Opaque RGB color; one with an alpha value of 1.0.
     * Because this method validates each intensity, it sacrifices performance for safety.
     * Although well suited for parsing color data generated by sensors or user input, this method undercuts
     * performance in applications like reading image data.
     *
     * To skip validation and minimize overhead, @see [[ai.dragonfly.color.RGB.apply]]
     *
     * @param red   decimal value from [0.0-1.0] representing the red component in RGB space.
     * @param green decimal value from [0.0-1.0] representing the green component in RGB space.
     * @param blue  decimal value from [0.0-1.0] representing the blue component in RGB space.
     * @return an instance of the RGB class or None if fed invalid input.
     */

    def getIfValid(red: Float, green: Float, blue: Float): Option[LRGB] = {
      if (valid0to1(red, green, blue)) Some(apply(red, green, blue))
      else None
    }

    /**
     * Use Color.random() to obtain a random color in the form of an RGB instance.
     * This method executes quickly and without memory costs, but the RGB color space biases toward cool colors.
     * In contrast, the Color.randomFromLabSpace() method takes seconds to initialize and has a memory footprint of several megabytes
     * However, it samples from a perceptually uniform color space and avoids the bias toward cool colors.
     * This method samples the Red, Green, and Blue color components uniformly, but always returns 1.0 for the alpha component.
     *
     * @return a randomly generated color sampled from the RGB Color ColorSpace.
     */
    override def random(r: scala.util.Random = Random.defaultRandom): LRGB = VecF[3](r.nextFloat(), r.nextFloat(), r.nextFloat())

    def red(lrgb:LRGB):Float = lrgb(0)
    def green(lrgb:LRGB):Float = lrgb(1)
    def blue(lrgb:LRGB):Float = lrgb(2)

    override def euclideanDistanceSquaredTo(c1: LRGB, c2: LRGB): Double = c1.euclideanDistanceSquaredTo(c2)

    override def fromVec(v: VecF[3]): LRGB = v

    override def fromRGB(rgb: RGB): LRGB = LRGB(
      transferFunction.decode(rgb.red),
      transferFunction.decode(rgb.green),
      transferFunction.decode(rgb.blue)
    )

    override def fromRGBA(rgba: RGBA): LRGB = LRGB(
      transferFunction.decode(rgba.red),
      transferFunction.decode(rgba.green),
      transferFunction.decode(rgba.blue)
    )

    override def fromXYZ(xyz:XYZ):LRGB = LRGB((M_inverse * xyz.vec.asColumnMatrix).values)

    override def fromXYZA(xyza: XYZA): LRGB = fromXYZ(xyza.toXYZ)
    
    override def toString:String = "LRGB"
  }

  type LRGB = LRGB.LRGB

  given VectorColorModel[3, LRGB] with {
    extension (lrgb: LRGB) {

      inline def red: Float = LRGB.red(lrgb)

      inline def green: Float = LRGB.green(lrgb)

      inline def blue: Float = LRGB.blue(lrgb)

      def copy: LRGB = LRGB(red, green, blue)

      override def vec: VecF[3] = lrgb.asInstanceOf[VecF[3]].copy

      override def similarity(that: LRGB): Double = LRGB.similarity(lrgb, that)

      override def toRGB: RGB = RGB(
        transferFunction.encode(lrgb.red),
        transferFunction.encode(lrgb.green),
        transferFunction.encode(lrgb.blue)
      )

      override def toRGBA: RGBA = RGBA(
        transferFunction.encode(lrgb.red),
        transferFunction.encode(lrgb.green),
        transferFunction.encode(lrgb.blue),
        1f
      )

      override def toRGBA(alpha: Float): RGBA = RGBA(
        transferFunction.encode(lrgb.red),
        transferFunction.encode(lrgb.green),
        transferFunction.encode(lrgb.blue),
        alpha
      )

      override def toXYZ: XYZ = (M * MatF[3, 1]( lrgb.red, lrgb.green, lrgb.blue )).values.asInstanceOf[XYZ]

      override def toXYZA: XYZA = {
        val xyz: XYZ = toXYZ
        XYZA(xyz.x, xyz.y, xyz.z, 1f)
      }

      override def toXYZA(alpha: Float): XYZA = {
        val xyz: XYZ = toXYZ
        XYZA(xyz.x, xyz.y, xyz.z, alpha)
      }

      override def render: String = s"LRGB($red,$green,$blue)"
    }
  }

  // LRGBA

  object LRGBA extends VectorSpace[4, LRGBA] {

    opaque type LRGBA = VecF[4]

    override lazy val usableGamut: Gamut = new Gamut( Cube(1.0, 32).toMeshF )

    override val maxDistanceSquared: Double = 4f

    def apply(values: NArray[Float]): LRGBA = dimensionCheck(values, 4).asInstanceOf[LRGBA]

    /**
     * Factory method to create a fully opaque RGB instance from separate, specified red, green, blue components and
     * a default alpha value of 1.0.
     * Float values that range outside of [0.0-1.0] may give unexpected results.  For values taken from user input, sensors,
     * or otherwise uncertain sources, consider using the factory method in the Color companion object.
     *
     * @see [[ai.dragonfly.color.ColorVectorSpace.RGB]] for a method of constructing RGB objects that validates inputs.
     * @param red   decimal value from [0.0-1.0] representing the red component in RGB space.
     * @param green decimal value from [0.0-1.0] representing the green component in RGB space.
     * @param blue  decimal value from [0.0-1.0] representing the blue component in RGB space.
     * @return an instance of the RGB type.
     */
    def apply(red: Float, green: Float, blue: Float): LRGBA = apply(NArray[Float](red, green, blue))

    /**
     * Factory method to create a fully opaque RGB instance from separate, specified red, green, blue components and
     * a default alpha value of 1.0.
     * Float values that range outside of [0.0-1.0] may give unexpected results.  For values taken from user input, sensors,
     * or otherwise uncertain sources, consider using the factory method in the Color companion object.
     *
     * @see [[ai.dragonfly.color.ColorVectorSpace.RGB]] for a method of constructing RGB objects that validates inputs.
     * @param red   decimal value from [0.0-1.0] representing the red component in RGB space.
     * @param green decimal value from [0.0-1.0] representing the green component in RGB space.
     * @param blue  decimal value from [0.0-1.0] representing the blue component in RGB space.
     * @param alpha  decimal value from [0.0-1.0] representing the alpha channel.
     * @return an instance of the LRGBA type.
     */
    def apply(red: Float, green: Float, blue: Float, alpha: Float): LRGBA = apply(NArray[Float](red, green, blue, alpha))

    /**
     * Factory method to create a fully Opaque RGB color; one with an alpha value of 1.0.
     * Because this method validates each intensity, it sacrifices performance for safety.
     * Although well suited for parsing color data generated by sensors or user input, this method undercuts
     * performance in applications like reading image data.
     *
     * To skip validation and minimize overhead, @see [[ai.dragonfly.color.RGB.apply]]
     *
     * @param red   decimal value from [0.0-1.0] representing the red component in RGB space.
     * @param green decimal value from [0.0-1.0] representing the green component in RGB space.
     * @param blue  decimal value from [0.0-1.0] representing the blue component in RGB space.
     * @return an instance of the LRGBA class or None if fed invalid input.
     */

    def getIfValid(red: Float, green: Float, blue: Float): Option[LRGBA] = {
      if (valid0to1(red, green, blue)) Some(apply(red, green, blue))
      else None
    }

    /**
     * Factory method to create a fully Opaque RGB color; one with an alpha value of 1.0.
     * Because this method validates each intensity, it sacrifices performance for safety.
     * Although well suited for parsing color data generated by sensors or user input, this method undercuts
     * performance in applications like reading image data.
     *
     * To skip validation and minimize overhead, @see [[ai.dragonfly.color.RGB.apply]]
     *
     * @param red   decimal value from [0.0-1.0] representing the red component in RGB space.
     * @param green decimal value from [0.0-1.0] representing the green component in RGB space.
     * @param blue  decimal value from [0.0-1.0] representing the blue component in RGB space.
     * @param alpha  decimal value from [0.0-1.0] representing the alpha channel.
     * @return an instance of the LRGBA class or None if fed invalid input.
     */

    def getIfValid(red: Float, green: Float, blue: Float, alpha: Float): Option[LRGBA] = {
      if (valid0to1(red, green, blue, alpha)) Some(apply(red, green, blue, alpha))
      else None
    }

    /**
     * Use Color.random() to obtain a random color in the form of an RGB instance.
     * This method executes quickly and without memory costs, but the RGB color space biases toward cool colors.
     * In contrast, the Color.randomFromLabSpace() method takes seconds to initialize and has a memory footprint of several megabytes
     * However, it samples from a perceptually uniform color space and avoids the bias toward cool colors.
     * This method samples the Red, Green, and Blue color components uniformly, but always returns 1.0 for the alpha component.
     *
     * @return a randomly generated color sampled from the RGB Color ColorSpace.
     */
    override def random(r: scala.util.Random = Random.defaultRandom): LRGBA = VecF[4](r.nextFloat(), r.nextFloat(), r.nextFloat(), r.nextFloat())

    def red(lrgba:LRGBA):Float = lrgba(0)
    def green(lrgba:LRGBA):Float = lrgba(1)
    def blue(lrgba:LRGBA):Float = lrgba(2)
    def alpha(lrgba:LRGBA):Float = lrgba(3)

    override def euclideanDistanceSquaredTo(c1: LRGBA, c2: LRGBA): Double = c1.euclideanDistanceSquaredTo(c2)

    override def fromVec(v: VecF[4]): LRGBA = v

    override def fromRGB(rgb: RGB): LRGBA = LRGBA(
      transferFunction.decode(rgb.red),
      transferFunction.decode(rgb.green),
      transferFunction.decode(rgb.blue)
    )

    override def fromRGBA(rgba: RGBA): LRGBA = LRGBA(
      transferFunction.decode(rgba.red),
      transferFunction.decode(rgba.green),
      transferFunction.decode(rgba.blue),
      rgba.alpha
    )

    override def fromXYZ(xyz:XYZ):LRGBA = LRGBA((M_inverse * xyz.vec.asColumnMatrix).values)

    override def fromXYZA(xyza: XYZA): LRGBA = fromXYZ(xyza.toXYZ)

    override def toString:String = "LRGBA"
  }

  type LRGBA = LRGBA.LRGBA

  given VectorColorModel[4, LRGBA] with {
    extension (lrgba: LRGBA) {

      inline def red: Float = LRGBA.red(lrgba)
      inline def green: Float = LRGBA.green(lrgba)
      inline def blue: Float = LRGBA.blue(lrgba)
      inline def alpha: Float = LRGBA.alpha(lrgba)

      def copy: LRGBA = LRGBA(red, green, blue, alpha)

      override def vec: VecF[4] = lrgba.asInstanceOf[VecF[4]].copy

      override def similarity(that: LRGBA): Double = LRGBA.similarity(lrgba, that)

      override def toRGB: RGB = RGB(
        transferFunction.encode(lrgba.red),
        transferFunction.encode(lrgba.green),
        transferFunction.encode(lrgba.blue)
      )

      override def toRGBA: RGBA = RGBA(
        transferFunction.encode(lrgba.red),
        transferFunction.encode(lrgba.green),
        transferFunction.encode(lrgba.blue),
        alpha
      )

      override def toRGBA(alpha: Float): RGBA = RGBA(
        transferFunction.encode(lrgba.red),
        transferFunction.encode(lrgba.green),
        transferFunction.encode(lrgba.blue),
        alpha
      )

      override def toXYZ: XYZ = (M * MatF[3, 1]( lrgba.red, lrgba.green, lrgba.blue )).values.asInstanceOf[XYZ]

      override def toXYZA: XYZA = {
        val xyz: XYZ = toXYZ
        XYZA(xyz.x, xyz.y, xyz.z, alpha)
      }

      override def toXYZA(alpha: Float): XYZA = {
        val xyz: XYZ = toXYZ
        XYZA(xyz.x, xyz.y, xyz.z, alpha)
      }

      override def render: String = s"LRGBA($red,$green,$blue,$alpha)"
    }
  }
}